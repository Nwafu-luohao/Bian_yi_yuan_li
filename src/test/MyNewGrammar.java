/* Generated By:JJTree&JavaCC: Do not edit this line. MyNewGrammar.java */
package test;
import util.*;
import java.io.*;

public class MyNewGrammar/*@bgen(jjtree)*/implements MyNewGrammarTreeConstants, MyNewGrammarConstants {/*@bgen(jjtree)*/
  protected JJTMyNewGrammarState jjtree = new JJTMyNewGrammarState();public QTList qtList = new QTList();

  public StatementType ST = new StatementType();

  public VariableTable Vt = new VariableTable();

  public void printQTTable(char [] buffer, FileWriter fos)
  {
    qtList.printQTTable(buffer, fos);
  }

  public static void main(String args [])
  {
    try
    {
      File outFile = new File("output5.txt");
      FileWriter fos = new FileWriter(outFile);
      FileReader reader = new FileReader("input5.txt");
      FileReader reader1 = new FileReader("input5.txt");
      char [] buffer = new char [1000];
      MyNewGrammar parser = new MyNewGrammar(reader);
      // 词法分析
      Token t = null;
      SimpleCharStream stream = new SimpleCharStream(reader1);
      MyNewGrammarTokenManager tmg = new MyNewGrammarTokenManager(stream);
      t = tmg.getNextToken();
      System.out.println("\u8bcd\u6cd5\u5206\u6790:\u005cn");
      String st = new String("\u8bcd\u6cd5\u5206\u6790:\u005cn");
      buffer = st.toCharArray();
      fos.write(buffer); // 写入文件
      while (t.kind != 0)
      {
        System.out.println(t.kind + " --- " + t.image);
        st = new String(t.kind + " --- " + t.image + "\u005cn");
        buffer = st.toCharArray();
        fos.write(buffer);
        t = tmg.getNextToken();
      }
      System.out.println("\u005cn");
      // 语法分析
      System.out.println("\u8bed\u6cd5\u5206\u6790: ");
      st = new String("\u005cn\u8bed\u6cd5\u5206\u6790:\u005cn");
      buffer = st.toCharArray();
      fos.write(buffer); // 写入文件
      SimpleNode n = parser.Start();
      n.dump("", buffer, fos);
      st = new String("Thank you.\u005cn\u005cn");
      buffer = st.toCharArray();
      fos.write(buffer); // 写入文件
      System.out.println("Thank you.");
      System.out.println("\u005cn");
      // 语义分析
      System.out.println("\u8bed\u4e49\u5206\u6790: \u005cn");
      st = new String("\u8bed\u4e49\u5206\u6790: \u005cn");
      buffer = st.toCharArray();
      fos.write(buffer); // 写入文件
      parser.printQTTable(buffer, fos);
      // 关闭并保存文件
      fos.close();
    }
    catch (Exception e)
    {
      System.out.println("Oops.");
      System.out.println(e.getMessage());
    }
  }

  final public SimpleNode Start() throws ParseException {
 /*@bgen(jjtree) Start */
  SimpleNode jjtn000 = new SimpleNode(JJTSTART);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      Program();
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public void Program() throws ParseException {
 /*@bgen(jjtree) Program */
  SimpleNode jjtn000 = new SimpleNode(JJTPROGRAM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      Type();
      jj_consume_token(MAIN);
      jj_consume_token(LB);
      jj_consume_token(RB);
      jj_consume_token(ZUOHUAKUO);
      label_1:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case INT:
        case VOID:
        case DOUBLE:
        case IF:
        case WHILE:
        case FOR:
        case SWITCH:
        case DO:
        case CHAR:
        case FLOAT:
        case SHORT:
        case LONG:
        case RETURN:
        case ZUOHUAKUO:
        case IDENTIFIER:
          ;
          break;
        default:
          jj_la1[0] = jj_gen;
          break label_1;
        }
        SentenceBlock();
      }
      jj_consume_token(YOUHUAKUO);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public String Type() throws ParseException {
 /*@bgen(jjtree) Type */
  SimpleNode jjtn000 = new SimpleNode(JJTTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t = null;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INT:
        t = jj_consume_token(INT);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    {if (true) return t.image;}
        break;
      case DOUBLE:
        t = jj_consume_token(DOUBLE);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    {if (true) return t.image;}
        break;
      case VOID:
        t = jj_consume_token(VOID);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    {if (true) return t.image;}
        break;
      case FLOAT:
        t = jj_consume_token(FLOAT);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    {if (true) return t.image;}
        break;
      case CHAR:
        t = jj_consume_token(CHAR);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    {if (true) return t.image;}
        break;
      case LONG:
        t = jj_consume_token(LONG);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    {if (true) return t.image;}
        break;
      case SHORT:
        t = jj_consume_token(SHORT);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    {if (true) return t.image;}
        break;
      default:
        jj_la1[1] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public void SentenceBlock() throws ParseException {
 /*@bgen(jjtree) SentenceBlock */
  SimpleNode jjtn000 = new SimpleNode(JJTSENTENCEBLOCK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INT:
      case VOID:
      case DOUBLE:
      case IF:
      case WHILE:
      case FOR:
      case SWITCH:
      case DO:
      case CHAR:
      case FLOAT:
      case SHORT:
      case LONG:
      case RETURN:
      case IDENTIFIER:
        Sentence();
        break;
      case ZUOHUAKUO:
        jj_consume_token(ZUOHUAKUO);
        label_2:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case INT:
          case VOID:
          case DOUBLE:
          case IF:
          case WHILE:
          case FOR:
          case SWITCH:
          case DO:
          case CHAR:
          case FLOAT:
          case SHORT:
          case LONG:
          case RETURN:
          case ZUOHUAKUO:
          case IDENTIFIER:
            ;
            break;
          default:
            jj_la1[2] = jj_gen;
            break label_2;
          }
          SentenceBlock();
        }
        jj_consume_token(YOUHUAKUO);
        break;
      default:
        jj_la1[3] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void Sentence() throws ParseException {
 /*@bgen(jjtree) Sentence */
  SimpleNode jjtn000 = new SimpleNode(JJTSENTENCE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INT:
      case VOID:
      case DOUBLE:
      case CHAR:
      case FLOAT:
      case SHORT:
      case LONG:
      case RETURN:
      case IDENTIFIER:
        SequenceSentence();
        break;
      case IF:
        ConditionSentence();
        break;
      case WHILE:
        LoopSentence();
        break;
      case DO:
        DoWhile();
        break;
      case SWITCH:
        SwitchSentence();
        break;
      case FOR:
        forSentence();
        break;
      default:
        jj_la1[4] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void SequenceSentence() throws ParseException {
 /*@bgen(jjtree) SequenceSentence */
  SimpleNode jjtn000 = new SimpleNode(JJTSEQUENCESENTENCE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INT:
      case VOID:
      case DOUBLE:
      case CHAR:
      case FLOAT:
      case SHORT:
      case LONG:
        StatementSentence();
        jj_consume_token(SP);
        break;
      case IDENTIFIER:
        AssignmentSentence();
        jj_consume_token(SP);
        break;
      case RETURN:
        ReturnSentence();
        jj_consume_token(SP);
        break;
      default:
        jj_la1[5] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void ReturnSentence() throws ParseException {
 /*@bgen(jjtree) ReturnSentence */
  SimpleNode jjtn000 = new SimpleNode(JJTRETURNSENTENCE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(RETURN);
      Expression();
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

// 变量重复声明
  final public void StatementSentence() throws ParseException {
 /*@bgen(jjtree) StatementSentence */
  SimpleNode jjtn000 = new SimpleNode(JJTSTATEMENTSENTENCE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token to = null;
  Variable va = new Variable();
  String ty = null;
    try {
      ty = Type();
      to = Identifier();
    va = new Variable(ty, to);
    Vt.addWithCheck(va);
    ST.setVariableTable(Vt);
      label_3:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DH:
          ;
          break;
        default:
          jj_la1[6] = jj_gen;
          break label_3;
        }
        jj_consume_token(DH);
        to = Identifier();
      va = new Variable(ty, to);
      Vt.addWithCheck(va);
      ST.setVariableTable(Vt);
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void AssignmentSentence() throws ParseException {
 /*@bgen(jjtree) AssignmentSentence */
  SimpleNode jjtn000 = new SimpleNode(JJTASSIGNMENTSENTENCE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);String str2 = null;
  String str1 = null;
  Token op, to;
  Variable va = new Variable();
    try {
      to = Identifier();
    str1 = to.image;
    va = Vt.variableExist(str1);
    if (va == null)
    {
      System.out.println("\u53d8\u91cf" + str1 + "\u672a\u5b9a\u4e49");
    }
      op = jj_consume_token(DENGYUHAO);
      str2 = Expression();
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    QTInfo qt = new QTInfo(op.image, str2, "_", str1);
    qtList.addQTInfo(qt);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void AssignmentSentence2() throws ParseException {
 /*@bgen(jjtree) AssignmentSentence2 */
  SimpleNode jjtn000 = new SimpleNode(JJTASSIGNMENTSENTENCE2);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);String str2 = null;
  String str1 = null;
  Token op, to;
  Variable va = new Variable();
    try {
      to = Identifier();
    str1 = to.image;
    va = Vt.variableExist(str1);
    if (va == null)
    {
      System.out.println("\u53d8\u91cf" + str1 + "\u672a\u5b9a\u4e49");
    }
      op = jj_consume_token(DENGYUHAO);
      str2 = Expression();
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    QTInfo qt = new QTInfo(op.image, str2, "_", str1);
    qtList.addQTInfo(qt);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void ConditionSentence() throws ParseException {
 /*@bgen(jjtree) ConditionSentence */
  SimpleNode jjtn000 = new SimpleNode(JJTCONDITIONSENTENCE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);ConditionValue cValue = new ConditionValue();
  int index;
    try {
      jj_consume_token(IF);
      jj_consume_token(LB);
      cValue = Condition();
      jj_consume_token(RB);
    cValue.backpatchTrueChain(QTInfo.size + 1);
      SentenceBlock();
    cValue.backpatchFalseChain(QTInfo.size + 1);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ELSE:
        jj_consume_token(ELSE);
      QTInfo qtInfo = new QTInfo("j", "_", "_", "F");
      index = QTInfo.size;
      qtList.addQTInfo(qtInfo);
      cValue.backpatchFalseChain(QTInfo.size + 1);
        SentenceBlock();
      qtInfo = qtList.get(index - 1);
      qtInfo.setResult(QTInfo.size + 1);
        break;
      default:
        jj_la1[7] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void LoopSentence() throws ParseException {
 /*@bgen(jjtree) LoopSentence */
  SimpleNode jjtn000 = new SimpleNode(JJTLOOPSENTENCE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);ConditionValue cValue = new ConditionValue();
  int index;
    try {
      jj_consume_token(WHILE);
      jj_consume_token(LB);
    index = QTInfo.size + 1;
      cValue = Condition();
      jj_consume_token(RB);
    cValue.backpatchTrueChain(QTInfo.size + 1);
      SentenceBlock();
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    QTInfo qtInfo = new QTInfo("j", "_", "_", index);
    qtList.addQTInfo(qtInfo);
    cValue.backpatchFalseChain(QTInfo.size + 1);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public ConditionValue Condition() throws ParseException {
 /*@bgen(jjtree) Condition */
  SimpleNode jjtn000 = new SimpleNode(JJTCONDITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);String e1 = null;
  String e2 = null;
  Token r = null;
  ConditionValue cValue = new ConditionValue();
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INTEGER_LITERAL:
      case LB:
      case IDENTIFIER:
        e1 = Expression();
        break;
      default:
        jj_la1[8] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LT:
      case LE:
      case GT:
      case GE:
        r = Rop();
        e2 = Expression();
        break;
      default:
        jj_la1[9] = jj_gen;
        ;
      }
    if (r == null || e1 == null)
    {
      if (e1 == null)
      {
        QTInfo qtInfo = new QTInfo("jnz", "_", "_", "T");
        qtList.addQTInfo(qtInfo);
        cValue.mergeTrue(qtInfo);
      }
      else
      {
        QTInfo qtInfo = new QTInfo("jnz", e1, "_", "T");
        qtList.addQTInfo(qtInfo);
        cValue.mergeTrue(qtInfo);
      }
    }
    else
    {
      QTInfo qtInfo = new QTInfo("j" + r.image, e1, e2, "T");
      qtList.addQTInfo(qtInfo);
      cValue.mergeTrue(qtInfo);
    }
    QTInfo qtInfo = new QTInfo("j", "_", "_", "F");
    qtList.addQTInfo(qtInfo);
    cValue.mergeFalse(qtInfo);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    {if (true) return cValue;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public Token Rop() throws ParseException {
 /*@bgen(jjtree) Rop */
  SimpleNode jjtn000 = new SimpleNode(JJTROP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t = null;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LT:
        t = jj_consume_token(LT);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    {if (true) return t;}
        break;
      case LE:
        t = jj_consume_token(LE);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    {if (true) return t;}
        break;
      case GT:
        t = jj_consume_token(GT);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    {if (true) return t;}
        break;
      case GE:
        t = jj_consume_token(GE);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    {if (true) return t;}
        break;
      default:
        jj_la1[10] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public String Expression() throws ParseException {
 /*@bgen(jjtree) Expression */
  SimpleNode jjtn000 = new SimpleNode(JJTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);String s = null;
    try {
      s = AdditiveExpression();
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    {if (true) return s;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public String AdditiveExpression() throws ParseException {
 /*@bgen(jjtree) AdditiveExpression */
  SimpleNode jjtn000 = new SimpleNode(JJTADDITIVEEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);String a = null;
  String b = null;
  String result = null;
  Token t = null;
    try {
      a = MultiplicativeExpression();
    result = a;
      label_4:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 87:
        case 88:
          ;
          break;
        default:
          jj_la1[11] = jj_gen;
          break label_4;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 87:
          t = jj_consume_token(87);
          break;
        case 88:
          t = jj_consume_token(88);
          break;
        default:
          jj_la1[12] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        b = MultiplicativeExpression();
      result = VariableNameGenerator.genVariableName();
      QTInfo qtInfo = new QTInfo(t.image, a, b, result);
      qtList.addQTInfo(qtInfo);
      a = result;
      }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    {if (true) return result;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public String MultiplicativeExpression() throws ParseException {
 /*@bgen(jjtree) MultiplicativeExpression */
  SimpleNode jjtn000 = new SimpleNode(JJTMULTIPLICATIVEEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);String a = null;
  String b = null;
  String result = null;
  Token t = null;
    try {
      a = UnaryExpression();
    result = a;
      label_5:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 89:
        case 90:
        case 91:
          ;
          break;
        default:
          jj_la1[13] = jj_gen;
          break label_5;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 89:
          t = jj_consume_token(89);
          break;
        case 90:
          t = jj_consume_token(90);
          break;
        case 91:
          t = jj_consume_token(91);
          break;
        default:
          jj_la1[14] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        b = UnaryExpression();
      result = VariableNameGenerator.genVariableName();
      QTInfo qtInfo = new QTInfo(t.image, a, b, result);
      qtList.addQTInfo(qtInfo);
      a = result;
      }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    {if (true) return result;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public String UnaryExpression() throws ParseException {
 /*@bgen(jjtree) UnaryExpression */
  SimpleNode jjtn000 = new SimpleNode(JJTUNARYEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);String str = null;
  Token to = null;
  Variable va = new Variable();
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LB:
        jj_consume_token(LB);
        str = Expression();
        jj_consume_token(RB);
        break;
      case IDENTIFIER:
        to = Identifier();
      str = to.image;
      va = Vt.variableExist(str);
      if (va == null)
      {
        System.out.println("\u53d8\u91cf" + str + "\u672a\u5b9a\u4e49");
      }
        break;
      case INTEGER_LITERAL:
        str = Integer();
        break;
      default:
        jj_la1[15] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    {if (true) return str;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public Token Identifier() throws ParseException {
 /*@bgen(jjtree) Identifier */
  SimpleNode jjtn000 = new SimpleNode(JJTIDENTIFIER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t = null;
    try {
      t = jj_consume_token(IDENTIFIER);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    {if (true) return t;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public String Integer() throws ParseException {
 /*@bgen(jjtree) Integer */
  SimpleNode jjtn000 = new SimpleNode(JJTINTEGER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t = null;
    try {
      t = jj_consume_token(INTEGER_LITERAL);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    {if (true) return t.image;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public ConditionValue Booler() throws ParseException {
 /*@bgen(jjtree) Booler */
  SimpleNode jjtn000 = new SimpleNode(JJTBOOLER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);ConditionValue Value = new ConditionValue();
  String str1 = null, str2 = null;
  Token op = null;
  Token op1 = null;
  ConditionValue Value2 = new ConditionValue();
  ConditionValue Valuet = new ConditionValue();
  int qtSize = QTInfo.size;
  QTInfo qt1;
  QTInfo qt2;
    try {
      str1 = Expression();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LT:
      case LE:
      case GT:
      case GE:
        op = Rop();
        str2 = Expression();
        break;
      default:
        jj_la1[16] = jj_gen;
        ;
      }
    if (op != null)
    {
      qt1 = new QTInfo("J" + op.image, str1, str2, QTInfo.size + 3);
      qtList.addQTInfo(qt1);
    }
    else
    {
      qt1 = new QTInfo("Jnz", str1, "_", QTInfo.size + 3);
      qtList.addQTInfo(qt1);
    }
    qt2 = new QTInfo("J", "_", "_", "F");
    qtList.addQTInfo(qt2);
    Value.mergeFalse(qt2);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OR:
      case AND:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case AND:
          op1 = jj_consume_token(AND);
        Valuet = new ConditionValue();
        Valuet.mergeFalse(qt2);
        Value.backpatchTrueChain(QTInfo.size + 1);
          break;
        case OR:
          op1 = jj_consume_token(OR);
          Valuet.mergeFalse(qt2);
          Valuet.backpatchFalseChain(QTInfo.size + 1);
          Value.backpatchFalseChain(QTInfo.size + 1);
          break;
        default:
          jj_la1[17] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        Value2 = Booler();
      if (op1.image.equals("&&"))
      {
        Value2.mergeFalse(qt2);
        Value2.backpatchFalseChain(QTInfo.size + 1);
      }
      if (op1.image.equals("||"))
      {
        Value2.mergeTrue(qt1);
        Value2.backpatchTrueChain(QTInfo.size + 1);
      }
      {if (true) return Value2;}
        break;
      default:
        jj_la1[18] = jj_gen;
        ;
      }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    {if (true) return Value;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public void SwitchSentence() throws ParseException {
 /*@bgen(jjtree) SwitchSentence */
  SimpleNode jjtn000 = new SimpleNode(JJTSWITCHSENTENCE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);ConditionValue Value = new ConditionValue();
  String str1 = null;
  String str2 = null;
  int qtSize = QTInfo.size;
  Token tok;
  Token tokx;
    try {
      jj_consume_token(SWITCH);
      jj_consume_token(LB);
      tok = jj_consume_token(IDENTIFIER);
      jj_consume_token(RB);
      jj_consume_token(ZUOHUAKUO);
      label_6:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CASE:
          ;
          break;
        default:
          jj_la1[19] = jj_gen;
          break label_6;
        }
        jj_consume_token(CASE);
        tokx = jj_consume_token(INTEGER_LITERAL);
      QTInfo qt1;
      if (tokx != null)
      {
        qt1 = new QTInfo("case", tok.image, tokx.image, QTInfo.size + 3);
        qtList.addQTInfo(qt1);
        Value.backpatchFalseChain(QTInfo.size);
        Value = new ConditionValue();
      }
      else
      {
        qt1 = new QTInfo("Jnz", tok.image, "_", QTInfo.size + 3);
        qtList.addQTInfo(qt1);
      }
      QTInfo qt2 = new QTInfo("J", "_", "_", "F");
      qtList.addQTInfo(qt2);
      Value.mergeFalse(qt2);
      Value.backpatchFalseChain(QTInfo.size + 2);
        jj_consume_token(COLON);
        label_7:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case INT:
          case VOID:
          case DOUBLE:
          case IF:
          case WHILE:
          case FOR:
          case SWITCH:
          case DO:
          case CHAR:
          case FLOAT:
          case SHORT:
          case LONG:
          case RETURN:
          case ZUOHUAKUO:
          case IDENTIFIER:
            ;
            break;
          default:
            jj_la1[20] = jj_gen;
            break label_7;
          }
          SentenceBlock();
        }
        jj_consume_token(BREAK);
        jj_consume_token(SP);
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DFLT:
        jj_consume_token(DFLT);
        jj_consume_token(COLON);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case INT:
        case VOID:
        case DOUBLE:
        case IF:
        case WHILE:
        case FOR:
        case SWITCH:
        case DO:
        case CHAR:
        case FLOAT:
        case SHORT:
        case LONG:
        case RETURN:
        case ZUOHUAKUO:
        case IDENTIFIER:
          SentenceBlock();
          break;
        default:
          jj_la1[21] = jj_gen;
          ;
        }
        jj_consume_token(BREAK);
        jj_consume_token(SP);
        break;
      default:
        jj_la1[22] = jj_gen;
        ;
      }
      jj_consume_token(YOUHUAKUO);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void DoWhile() throws ParseException {
 /*@bgen(jjtree) DoWhile */
  SimpleNode jjtn000 = new SimpleNode(JJTDOWHILE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);int QTSize = QTInfo.size;
  ConditionValue Value = null;
  String str1 = null;
  String str2 = null;
  Token op = null;
    try {
      jj_consume_token(DO);
      SentenceBlock();
      jj_consume_token(WHILE);
      jj_consume_token(LB);
      Value = Booler();
      jj_consume_token(RB);
      jj_consume_token(SP);
    Value.backpatchTrueChain(QTSize + 1);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    Value.backpatchFalseChain(QTInfo.size + 1);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void forSentence() throws ParseException {
 /*@bgen(jjtree) forSentence */
  SimpleNode jjtn000 = new SimpleNode(JJTFORSENTENCE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);ConditionValue cValue = new ConditionValue();
  int index;
    try {
      jj_consume_token(FOR);
      jj_consume_token(LB);
    index = QTInfo.size + 1;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INT:
      case VOID:
      case DOUBLE:
      case CHAR:
      case FLOAT:
      case SHORT:
      case LONG:
      case IDENTIFIER:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case INT:
        case VOID:
        case DOUBLE:
        case CHAR:
        case FLOAT:
        case SHORT:
        case LONG:
          StatementSentence();
          break;
        case IDENTIFIER:
          AssignmentSentence2();
          break;
        default:
          jj_la1[23] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[24] = jj_gen;
        ;
      }
      jj_consume_token(SP);
      cValue = Condition();
      jj_consume_token(SP);
      label_8:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IDENTIFIER:
          ;
          break;
        default:
          jj_la1[25] = jj_gen;
          break label_8;
        }
        AssignmentSentence2();
      }
      jj_consume_token(RB);
    cValue.backpatchTrueChain(QTInfo.size + 1);
      SentenceBlock();
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    QTInfo qtInfo = new QTInfo("j", "_", "_", index);
    qtList.addQTInfo(qtInfo);
    cValue.backpatchFalseChain(QTInfo.size + 1);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  /** Generated Token Manager. */
  public MyNewGrammarTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[26];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
      jj_la1_init_2();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x5f6d8000,0x5c058000,0x5f6d8000,0x5f6d8000,0x5f6d8000,0x5c058000,0x0,0x100000,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x80,0x0,0x80000000,0x80000000,0x20000000,0x5f6d8000,0x5f6d8000,0x800000,0x5c058000,0x5c058000,0x0,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x10000,0x0,0x10000,0x10000,0x10000,0x10000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x1,0x0,0x10000,0x10000,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_init_2() {
      jj_la1_2 = new int[] {0x100800,0x0,0x100800,0x100800,0x100000,0x100000,0x40,0x0,0x100100,0x1e,0x1e,0x1800000,0x1800000,0xe000000,0xe000000,0x100100,0x1e,0x0,0x0,0x0,0x100800,0x100800,0x0,0x100000,0x100000,0x100000,};
   }

  /** Constructor with InputStream. */
  public MyNewGrammar(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public MyNewGrammar(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new MyNewGrammarTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 26; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 26; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public MyNewGrammar(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new MyNewGrammarTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 26; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 26; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public MyNewGrammar(MyNewGrammarTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 26; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(MyNewGrammarTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 26; i++) jj_la1[i] = -1;
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[92];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 26; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 92; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

}
